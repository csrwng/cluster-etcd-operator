// Code generated by go-bindata.
// sources:
// config/crds/etcd_v1_dnsendpoint.yaml
// config/crds/etcd_v1_etcdconfig.yaml
// config/default/kustomization.yaml
// config/default/manager_auth_proxy_patch.yaml
// config/default/manager_image_patch.yaml
// config/default/manager_prometheus_metrics_patch.yaml
// config/external-dns/binding.yaml
// config/external-dns/deployment.yaml
// config/external-dns/namespace.yaml
// config/external-dns/role.yaml
// config/external-dns/sa.yaml
// config/manager/manager.yaml
// config/operator/config.yaml
// config/rbac/auth_proxy_role.yaml
// config/rbac/auth_proxy_role_binding.yaml
// config/rbac/auth_proxy_service.yaml
// config/rbac/rbac_role.yaml
// config/rbac/rbac_role_binding.yaml
// DO NOT EDIT!

package assets

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _configCrdsEtcd_v1_dnsendpointYaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  creationTimestamp: null
  labels:
    controller-tools.k8s.io: "1.0"
  name: dnsendpoints.etcd.operator.openshift.io
spec:
  group: etcd.operator.openshift.io
  names:
    kind: DNSEndpoint
    plural: dnsendpoints
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          properties:
            endpoints:
              description: Endpoints is the list of DNS records to create/update
              items:
                properties:
                  dnsName:
                    description: The hostname of the DNS record
                    type: string
                  labels:
                    description: Labels stores labels defined for the Endpoint
                    type: object
                  providerSpecific:
                    description: ProviderSpecific stores provider specific config
                    type: object
                  recordTTL:
                    description: TTL for the record
                    format: int64
                    type: integer
                  recordType:
                    description: RecordType type of record, e.g. CNAME, A, SRV, TXT
                      etc
                    type: string
                  targets:
                    description: The targets the DNS record points to
                    items:
                      type: string
                    type: array
                type: object
              type: array
          type: object
        status:
          properties:
            observedGeneration:
              description: ObservedGeneration is the generation observed by the external-dns
                controller.
              format: int64
              type: integer
          type: object
  version: v1
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
`)

func configCrdsEtcd_v1_dnsendpointYamlBytes() ([]byte, error) {
	return _configCrdsEtcd_v1_dnsendpointYaml, nil
}

func configCrdsEtcd_v1_dnsendpointYaml() (*asset, error) {
	bytes, err := configCrdsEtcd_v1_dnsendpointYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/crds/etcd_v1_dnsendpoint.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configCrdsEtcd_v1_etcdconfigYaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  creationTimestamp: null
  labels:
    controller-tools.k8s.io: "1.0"
  name: etcdconfigs.etcd.operator.openshift.io
spec:
  group: etcd.operator.openshift.io
  names:
    kind: EtcdConfig
    plural: etcdconfigs
  scope: Cluster
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          properties:
            dnsConfig:
              description: dnsConfig specifies configuration for etcd DNS entry management
              properties:
                automaticUpdates:
                  description: automaticUpdates indicates that the DNS entries should
                    be automatically updated based on the IP address of master Machine
                    resources
                  type: boolean
                logLevel:
                  description: 'logLevel is the level of logging for the external-dns
                    controller Valid values: debug, info, warning, error, fatal'
                  type: string
              required:
              - automaticUpdates
              type: object
            managementState:
              description: managementState indicates whether and how the operator
                should manage the component
              type: string
          required:
          - managementState
          - dnsConfig
          type: object
        status:
          properties:
            conditions:
              description: conditions is a list of conditions and their status
              items:
                properties:
                  lastTransitionTime:
                    format: date-time
                    type: string
                  message:
                    type: string
                  reason:
                    type: string
                  status:
                    type: string
                  type:
                    type: string
                required:
                - type
                - status
                type: object
              type: array
            generations:
              description: generations are used to determine when an item needs to
                be reconciled or has changed in a way that needs a reaction.
              items:
                properties:
                  group:
                    description: group is the group of the thing you're tracking
                    type: string
                  hash:
                    description: hash is an optional field set for resources without
                      generation that are content sensitive like secrets and configmaps
                    type: string
                  lastGeneration:
                    description: lastGeneration is the last generation of the workload
                      controller involved
                    format: int64
                    type: integer
                  name:
                    description: name is the name of the thing you're tracking
                    type: string
                  namespace:
                    description: namespace is where the thing you're tracking is
                    type: string
                  resource:
                    description: resource is the resource type of the thing you're
                      tracking
                    type: string
                required:
                - group
                - resource
                - namespace
                - name
                - lastGeneration
                - hash
                type: object
              type: array
            observedGeneration:
              description: observedGeneration is the last generation change you've
                dealt with
              format: int64
              type: integer
            readyReplicas:
              description: readyReplicas indicates how many replicas are ready and
                at the desired state
              format: int32
              type: integer
            version:
              description: version is the level this availability applies to
              type: string
          required:
          - version
          - readyReplicas
          - generations
          type: object
  version: v1
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
`)

func configCrdsEtcd_v1_etcdconfigYamlBytes() ([]byte, error) {
	return _configCrdsEtcd_v1_etcdconfigYaml, nil
}

func configCrdsEtcd_v1_etcdconfigYaml() (*asset, error) {
	bytes, err := configCrdsEtcd_v1_etcdconfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/crds/etcd_v1_etcdconfig.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configDefaultKustomizationYaml = []byte(`# Adds namespace to all resources.
namespace: cluster-etcd-operator-system

# Value of this field is prepended to the
# names of all resources, e.g. a deployment named
# "wordpress" becomes "alices-wordpress".
# Note that it should also match with the prefix (text before '-') of the namespace
# field above.
namePrefix: cluster-etcd-operator-

# Labels to add to all resources and selectors.
#commonLabels:
#  someName: someValue

# Each entry in this list must resolve to an existing
# resource definition in YAML.  These are the resource
# files that kustomize reads, modifies and emits as a
# YAML string, with resources separated by document
# markers ("---").
resources:
- ../rbac/rbac_role.yaml
- ../rbac/rbac_role_binding.yaml
- ../manager/manager.yaml
  # Comment the following 3 lines if you want to disable
  # the auth proxy (https://github.com/brancz/kube-rbac-proxy)
  # which protects your /metrics endpoint.
- ../rbac/auth_proxy_service.yaml
- ../rbac/auth_proxy_role.yaml
- ../rbac/auth_proxy_role_binding.yaml

patches:
- manager_image_patch.yaml
  # Protect the /metrics endpoint by putting it behind auth.
  # Only one of manager_auth_proxy_patch.yaml and
  # manager_prometheus_metrics_patch.yaml should be enabled.
- manager_auth_proxy_patch.yaml
  # If you want your controller-manager to expose the /metrics
  # endpoint w/o any authn/z, uncomment the following line and
  # comment manager_auth_proxy_patch.yaml.
  # Only one of manager_auth_proxy_patch.yaml and
  # manager_prometheus_metrics_patch.yaml should be enabled.
#- manager_prometheus_metrics_patch.yaml

vars:
- name: WEBHOOK_SECRET_NAME
  objref:
    kind: Secret
    name: webhook-server-secret
    apiVersion: v1
`)

func configDefaultKustomizationYamlBytes() ([]byte, error) {
	return _configDefaultKustomizationYaml, nil
}

func configDefaultKustomizationYaml() (*asset, error) {
	bytes, err := configDefaultKustomizationYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/default/kustomization.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configDefaultManager_auth_proxy_patchYaml = []byte(`# This patch inject a sidecar container which is a HTTP proxy for the controller manager,
# it performs RBAC authorization against the Kubernetes API using SubjectAccessReviews.
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: controller-manager
  namespace: system
spec:
  template:
    spec:
      containers:
      - name: kube-rbac-proxy
        image: gcr.io/kubebuilder/kube-rbac-proxy:v0.4.0
        args:
        - "--secure-listen-address=0.0.0.0:8443"
        - "--upstream=http://127.0.0.1:8080/"
        - "--logtostderr=true"
        - "--v=10"
        ports:
        - containerPort: 8443
          name: https
      - name: manager
        args:
        - "--metrics-addr=127.0.0.1:8080"
`)

func configDefaultManager_auth_proxy_patchYamlBytes() ([]byte, error) {
	return _configDefaultManager_auth_proxy_patchYaml, nil
}

func configDefaultManager_auth_proxy_patchYaml() (*asset, error) {
	bytes, err := configDefaultManager_auth_proxy_patchYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/default/manager_auth_proxy_patch.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configDefaultManager_image_patchYaml = []byte(`apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: controller-manager
  namespace: system
spec:
  template:
    spec:
      containers:
      # Change the value of image field below to your controller image URL
      - image: IMAGE_URL
        name: manager
`)

func configDefaultManager_image_patchYamlBytes() ([]byte, error) {
	return _configDefaultManager_image_patchYaml, nil
}

func configDefaultManager_image_patchYaml() (*asset, error) {
	bytes, err := configDefaultManager_image_patchYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/default/manager_image_patch.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configDefaultManager_prometheus_metrics_patchYaml = []byte(`# This patch enables Prometheus scraping for the manager pod.
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: controller-manager
  namespace: system
spec:
  template:
    metadata:
      annotations:
        prometheus.io/scrape: 'true'
    spec:
      containers:
      # Expose the prometheus metrics on default port
      - name: manager
        ports:
        - containerPort: 8080
          name: metrics
          protocol: TCP
`)

func configDefaultManager_prometheus_metrics_patchYamlBytes() ([]byte, error) {
	return _configDefaultManager_prometheus_metrics_patchYaml, nil
}

func configDefaultManager_prometheus_metrics_patchYaml() (*asset, error) {
	bytes, err := configDefaultManager_prometheus_metrics_patchYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/default/manager_prometheus_metrics_patch.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configExternalDnsBindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  creationTimestamp: null
  name: external-dns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
- kind: ServiceAccount
  name: external-dns
  namespace: openshift-cluster-etcd-dns
`)

func configExternalDnsBindingYamlBytes() ([]byte, error) {
	return _configExternalDnsBindingYaml, nil
}

func configExternalDnsBindingYaml() (*asset, error) {
	bytes, err := configExternalDnsBindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/external-dns/binding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configExternalDnsDeploymentYaml = []byte(`apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-dns
  namespace: openshift-cluster-etcd-dns
spec:
  replicas: 1
  selector:
    matchLabels:
      name: external-dns
  template:
    metadata:
      labels:
        name: external-dns
    spec:
      strategy:
        type: Recreate
      serviceAccountName: external-dns
      priorityClassName: system-cluster-critical
      containers:
      - name: external-dns
        image: quay.io/openshift/external-dns:latest
        args:
        - --source=crd
        - --crd-source-apiversion=etcd.operator.openshift.io/v1
        - --crd-source-kind=DNSEndpoint
        - --registry=noop
        - --policy=upsert-only
        - --namespace=openshift-etcd-dns

`)

func configExternalDnsDeploymentYamlBytes() ([]byte, error) {
	return _configExternalDnsDeploymentYaml, nil
}

func configExternalDnsDeploymentYaml() (*asset, error) {
	bytes, err := configExternalDnsDeploymentYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/external-dns/deployment.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configExternalDnsNamespaceYaml = []byte(`kind: Namespace
apiVersion: v1
metadata:
  name: openshift-cluster-etcd-dns
`)

func configExternalDnsNamespaceYamlBytes() ([]byte, error) {
	return _configExternalDnsNamespaceYaml, nil
}

func configExternalDnsNamespaceYaml() (*asset, error) {
	bytes, err := configExternalDnsNamespaceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/external-dns/namespace.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configExternalDnsRoleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns
rules:
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get","watch","list"]
- apiGroups: ["etcd.operator.openshift.io"]
  resources: ["dnsendpoints", "dnsendpoints/status"]
  verbs: ["get","list","watch","create","update","patch","delete"]
`)

func configExternalDnsRoleYamlBytes() ([]byte, error) {
	return _configExternalDnsRoleYaml, nil
}

func configExternalDnsRoleYaml() (*asset, error) {
	bytes, err := configExternalDnsRoleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/external-dns/role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configExternalDnsSaYaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
  namespace: openshift-cluster-etcd-dns
`)

func configExternalDnsSaYamlBytes() ([]byte, error) {
	return _configExternalDnsSaYaml, nil
}

func configExternalDnsSaYaml() (*asset, error) {
	bytes, err := configExternalDnsSaYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/external-dns/sa.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configManagerManagerYaml = []byte(`apiVersion: v1
kind: Namespace
metadata:
  labels:
    control-plane: controller-manager
    controller-tools.k8s.io: "1.0"
  name: system
---
apiVersion: v1
kind: Service
metadata:
  name: controller-manager-service
  namespace: system
  labels:
    control-plane: controller-manager
    controller-tools.k8s.io: "1.0"
spec:
  selector:
    control-plane: controller-manager
    controller-tools.k8s.io: "1.0"
  ports:
  - port: 443
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: controller-manager
  namespace: system
  labels:
    control-plane: controller-manager
    controller-tools.k8s.io: "1.0"
spec:
  selector:
    matchLabels:
      control-plane: controller-manager
      controller-tools.k8s.io: "1.0"
  serviceName: controller-manager-service
  template:
    metadata:
      labels:
        control-plane: controller-manager
        controller-tools.k8s.io: "1.0"
    spec:
      containers:
      - command:
        - /manager
        image: controller:latest
        imagePullPolicy: Always
        name: manager
        env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: SECRET_NAME
            value: $(WEBHOOK_SECRET_NAME)
        resources:
          limits:
            cpu: 100m
            memory: 30Mi
          requests:
            cpu: 100m
            memory: 20Mi
        ports:
        - containerPort: 9876
          name: webhook-server
          protocol: TCP
        volumeMounts:
        - mountPath: /tmp/cert
          name: cert
          readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: webhook-server-secret
---
apiVersion: v1
kind: Secret
metadata:
  name: webhook-server-secret
  namespace: system
`)

func configManagerManagerYamlBytes() ([]byte, error) {
	return _configManagerManagerYaml, nil
}

func configManagerManagerYaml() (*asset, error) {
	bytes, err := configManagerManagerYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/manager/manager.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configOperatorConfigYaml = []byte(`apiVersion: etcd.operator.openshift.io/v1
kind: EtcdConfig
metadata:
  name: instance
spec:
  managementState: Managed
  dnsConfig:
    automaticUpdates: true
    logLevel: info
`)

func configOperatorConfigYamlBytes() ([]byte, error) {
	return _configOperatorConfigYaml, nil
}

func configOperatorConfigYaml() (*asset, error) {
	bytes, err := configOperatorConfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/operator/config.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configRbacAuth_proxy_roleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: proxy-role
rules:
- apiGroups: ["authentication.k8s.io"]
  resources:
  - tokenreviews
  verbs: ["create"]
- apiGroups: ["authorization.k8s.io"]
  resources:
  - subjectaccessreviews
  verbs: ["create"]
`)

func configRbacAuth_proxy_roleYamlBytes() ([]byte, error) {
	return _configRbacAuth_proxy_roleYaml, nil
}

func configRbacAuth_proxy_roleYaml() (*asset, error) {
	bytes, err := configRbacAuth_proxy_roleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/rbac/auth_proxy_role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configRbacAuth_proxy_role_bindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: proxy-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: system
`)

func configRbacAuth_proxy_role_bindingYamlBytes() ([]byte, error) {
	return _configRbacAuth_proxy_role_bindingYaml, nil
}

func configRbacAuth_proxy_role_bindingYaml() (*asset, error) {
	bytes, err := configRbacAuth_proxy_role_bindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/rbac/auth_proxy_role_binding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configRbacAuth_proxy_serviceYaml = []byte(`apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/port: "8443"
    prometheus.io/scheme: https
    prometheus.io/scrape: "true"
  labels:
    control-plane: controller-manager
    controller-tools.k8s.io: "1.0"
  name: controller-manager-metrics-service
  namespace: system
spec:
  ports:
  - name: https
    port: 8443
    targetPort: https
  selector:
    control-plane: controller-manager
    controller-tools.k8s.io: "1.0"
`)

func configRbacAuth_proxy_serviceYamlBytes() ([]byte, error) {
	return _configRbacAuth_proxy_serviceYaml, nil
}

func configRbacAuth_proxy_serviceYaml() (*asset, error) {
	bytes, err := configRbacAuth_proxy_serviceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/rbac/auth_proxy_service.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configRbacRbac_roleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  name: manager-role
rules:
- apiGroups:
  - apps
  resources:
  - deployments
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - apps
  resources:
  - deployments/status
  verbs:
  - get
  - update
  - patch
- apiGroups:
  - etcd.operator.openshift.io
  resources:
  - etcdconfigs
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - etcd.operator.openshift.io
  resources:
  - etcdconfigs/status
  verbs:
  - get
  - update
  - patch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  - validatingwebhookconfigurations
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
`)

func configRbacRbac_roleYamlBytes() ([]byte, error) {
	return _configRbacRbac_roleYaml, nil
}

func configRbacRbac_roleYaml() (*asset, error) {
	bytes, err := configRbacRbac_roleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/rbac/rbac_role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _configRbacRbac_role_bindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  creationTimestamp: null
  name: manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: manager-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: system
`)

func configRbacRbac_role_bindingYamlBytes() ([]byte, error) {
	return _configRbacRbac_role_bindingYaml, nil
}

func configRbacRbac_role_bindingYaml() (*asset, error) {
	bytes, err := configRbacRbac_role_bindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "config/rbac/rbac_role_binding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"config/crds/etcd_v1_dnsendpoint.yaml":                 configCrdsEtcd_v1_dnsendpointYaml,
	"config/crds/etcd_v1_etcdconfig.yaml":                  configCrdsEtcd_v1_etcdconfigYaml,
	"config/default/kustomization.yaml":                    configDefaultKustomizationYaml,
	"config/default/manager_auth_proxy_patch.yaml":         configDefaultManager_auth_proxy_patchYaml,
	"config/default/manager_image_patch.yaml":              configDefaultManager_image_patchYaml,
	"config/default/manager_prometheus_metrics_patch.yaml": configDefaultManager_prometheus_metrics_patchYaml,
	"config/external-dns/binding.yaml":                     configExternalDnsBindingYaml,
	"config/external-dns/deployment.yaml":                  configExternalDnsDeploymentYaml,
	"config/external-dns/namespace.yaml":                   configExternalDnsNamespaceYaml,
	"config/external-dns/role.yaml":                        configExternalDnsRoleYaml,
	"config/external-dns/sa.yaml":                          configExternalDnsSaYaml,
	"config/manager/manager.yaml":                          configManagerManagerYaml,
	"config/operator/config.yaml":                          configOperatorConfigYaml,
	"config/rbac/auth_proxy_role.yaml":                     configRbacAuth_proxy_roleYaml,
	"config/rbac/auth_proxy_role_binding.yaml":             configRbacAuth_proxy_role_bindingYaml,
	"config/rbac/auth_proxy_service.yaml":                  configRbacAuth_proxy_serviceYaml,
	"config/rbac/rbac_role.yaml":                           configRbacRbac_roleYaml,
	"config/rbac/rbac_role_binding.yaml":                   configRbacRbac_role_bindingYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"config": {nil, map[string]*bintree{
		"crds": {nil, map[string]*bintree{
			"etcd_v1_dnsendpoint.yaml": {configCrdsEtcd_v1_dnsendpointYaml, map[string]*bintree{}},
			"etcd_v1_etcdconfig.yaml":  {configCrdsEtcd_v1_etcdconfigYaml, map[string]*bintree{}},
		}},
		"default": {nil, map[string]*bintree{
			"kustomization.yaml":                    {configDefaultKustomizationYaml, map[string]*bintree{}},
			"manager_auth_proxy_patch.yaml":         {configDefaultManager_auth_proxy_patchYaml, map[string]*bintree{}},
			"manager_image_patch.yaml":              {configDefaultManager_image_patchYaml, map[string]*bintree{}},
			"manager_prometheus_metrics_patch.yaml": {configDefaultManager_prometheus_metrics_patchYaml, map[string]*bintree{}},
		}},
		"external-dns": {nil, map[string]*bintree{
			"binding.yaml":    {configExternalDnsBindingYaml, map[string]*bintree{}},
			"deployment.yaml": {configExternalDnsDeploymentYaml, map[string]*bintree{}},
			"namespace.yaml":  {configExternalDnsNamespaceYaml, map[string]*bintree{}},
			"role.yaml":       {configExternalDnsRoleYaml, map[string]*bintree{}},
			"sa.yaml":         {configExternalDnsSaYaml, map[string]*bintree{}},
		}},
		"manager": {nil, map[string]*bintree{
			"manager.yaml": {configManagerManagerYaml, map[string]*bintree{}},
		}},
		"operator": {nil, map[string]*bintree{
			"config.yaml": {configOperatorConfigYaml, map[string]*bintree{}},
		}},
		"rbac": {nil, map[string]*bintree{
			"auth_proxy_role.yaml":         {configRbacAuth_proxy_roleYaml, map[string]*bintree{}},
			"auth_proxy_role_binding.yaml": {configRbacAuth_proxy_role_bindingYaml, map[string]*bintree{}},
			"auth_proxy_service.yaml":      {configRbacAuth_proxy_serviceYaml, map[string]*bintree{}},
			"rbac_role.yaml":               {configRbacRbac_roleYaml, map[string]*bintree{}},
			"rbac_role_binding.yaml":       {configRbacRbac_role_bindingYaml, map[string]*bintree{}},
		}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
